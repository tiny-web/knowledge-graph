const { prompt } = require('/opt/nodejs/node20/openAI');
const { createUserAndApp, insertDataWithUserAndApp, validateCypher } = require('/opt/nodejs/node20/neo4j.js');
const { fetchFromDdb } = require('/opt/nodejs/node20/ddb'); // Import the DynamoDB fetch utility

const headers = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "OPTIONS,POST,GET",
  "Access-Control-Allow-Headers": "Content-Type",
  "Access-Control-Allow-Credentials": 'true',
  'Content-Type': 'application/json'
};

const NEO4J_URI = process.env.NEO4J_URI;
const NEO4J_USER = process.env.NEO4J_USER;
const NEO4J_PASSWORD = process.env.NEO4J_PASSWORD;
const OPEN_AI_API_KEY = process.env.OPEN_AI_API_KEY;
const KG_APP_CONFIG_TABLE_NAME = process.env.KG_APP_CONFIG_TABLE_NAME;

exports.handler = async (event) => {
  try {
    console.log("Event: ", JSON.stringify(event, null, 2));

    // Extract required fields from the event body
    const { content, user_id, app_id } = JSON.parse(event.body || {});

    // Step 1: Fetch app configuration from DynamoDB
    const appConfig = await fetchFromDdb({TableName: KG_APP_CONFIG_TABLE_NAME, Key: {id: app_id} });
    if (!appConfig) {
      throw new Error(`No configuration found for app_id: ${app_id}`);
    }

    const { entities_allowed, relations_allowed, relation_rules } = appConfig;

    if (!Array.isArray(entities_allowed) || !Array.isArray(relations_allowed) || !relation_rules) {
      throw new Error(`Invalid configuration for app_id: ${app_id}`);
    }

    // Step 2: Generate Cypher queries using OpenAI
    const q = `
You are an expert in data extraction and Cypher query generation for Neo4j knowledge graphs. 
Your task is to process the JSON input and ensure that all nodes and relationships are correctly created, adhering to the following instructions:

1. Input JSON Structure:
   {
     "content": ${JSON.stringify(content)},
     "user_id": ${user_id},
     "app_id": ${app_id},
     "include_nodes": ${JSON.stringify(entities_allowed)},
     "relations": ${JSON.stringify(relations_allowed)}
   }

2. Use the rules from the relation_rules field to determine the valid relationships between nodes:
   ${JSON.stringify(relation_rules)}

3. Structured and Parameterized Queries:
   - Use the following style for Cypher queries:
     1. Match the User and App nodes:
        MATCH (user:User {id: $user_id}), (app:App {id: $app_id})
     2. Use MERGE to create relationships between the nodes:
        MERGE (user)-[:MEMBER_OF]->(app)
     3. For other nodes and relationships, match the User node and then create the relationship:
        MATCH (user:User {id: $user_id})
        MERGE (node:NodeType {property: 'value'})-[:OWNED_BY]->(user)

4. Ensure Valid Query Structure:
   - Every MATCH statement must be followed by an operation such as MERGE, RETURN, or CREATE.
   - Standalone MATCH statements are not valid and should not be included.

5. Separate Queries:
   - Generate Cypher queries for creating the User and App nodes and the MEMBER_OF relationship first.
   - Generate separate Cypher queries for other nodes and relationships linked to the User and App.
   - do check if app description is there int he information, if so always update/create DESCRIPTION node
   - do not add any comments to the cypher queries

7. Example Output: dont prefix json literal in the output. keep out json output. provide only json format
   {
     "userAppQueries": [
       "MATCH (user:User {id: $user_id}), (app:App {id: $app_id})",
       "MERGE (user)-[:MEMBER_OF]->(app)"
     ],
     "otherQueries": [
       "MATCH (user:User {id: $user_id}) MERGE (website:Website {name: 'This website'})-[:OWNED_BY]->(user)",
       "MATCH (user:User {id: $user_id}) MERGE (feature1:Feature {description: 'AI-powered search'})-[:OWNED_BY]->(user)",
       "MATCH (user:User {id: $user_id}) MERGE (pricing:Pricing {model: 'affordable'})-[:OWNED_BY]->(user)"
     ]
   }

Process the input and generate the Cypher queries as per the instructions.
`;

    const { userAppQueries, otherQueries } = await prompt({ q, OPEN_AI_API_KEY, isJSON: true, max_tokens: 3000 });

    if (!validateCypher(userAppQueries) || !validateCypher(otherQueries)) {
      throw new Error("Invalid Cypher queries generated by OpenAI.");
    }

    // Step 3: Execute User and App queries
    const userAppResult = await createUserAndApp(user_id, app_id, {
      uri: NEO4J_URI,
      user: NEO4J_USER,
      password: NEO4J_PASSWORD
    });

    if (!userAppResult.success) {
      throw new Error("Failed to execute User and App queries: " + userAppResult.error);
    }

    // Step 4: Execute other queries
    const dataResult = await insertDataWithUserAndApp(
      otherQueries,
      { user_id, app_id },
      { uri: NEO4J_URI, user: NEO4J_USER, password: NEO4J_PASSWORD }
    );

    if (!dataResult.success) {
      throw new Error("Error inserting other data: " + dataResult.error);
    }

    return {
      statusCode: 200,
      body: JSON.stringify({ message: "Knowledge has been successfully ingested." }),
      headers
    };

  } catch (err) {
    console.error("Error:", err);
    return {
      statusCode: 500,
      body: JSON.stringify({ error: "Internal server error", details: err.message }),
      headers
    };
  }
};